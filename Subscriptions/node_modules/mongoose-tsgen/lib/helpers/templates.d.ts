export declare const MAIN_HEADER = "/* tslint:disable */\n/* eslint-disable */\n\n// ######################################## THIS FILE WAS GENERATED BY MONGOOSE-TSGEN ######################################## //\n\n// NOTE: ANY CHANGES MADE WILL BE OVERWRITTEN ON SUBSEQUENT EXECUTIONS OF MONGOOSE-TSGEN.";
export declare const MONGOOSE_IMPORT = "import mongoose from \"mongoose\";";
export declare const POPULATE_HELPERS = "/**\n * Check if a property on a document is populated:\n * ```\n * import { IsPopulated } from \"../interfaces/mongoose.gen.ts\"\n * \n * if (IsPopulated<UserDocument[\"bestFriend\"]>) { ... }\n * ```\n */\nexport function IsPopulated<T>(doc: T | mongoose.Types.ObjectId): doc is T {\n  return doc instanceof mongoose.Document;\n}\n\n/**\n * Helper type used by `PopulatedDocument`. Returns the parent property of a string \n * representing a nested property (i.e. `friend.user` -> `friend`)\n */\ntype ParentProperty<T> = T extends `${infer P}.${string}` ? P : never;\n\n/**\n* Helper type used by `PopulatedDocument`. Returns the child property of a string \n* representing a nested property (i.e. `friend.user` -> `user`).\n*/\ntype ChildProperty<T> = T extends `${string}.${infer C}` ? C : never;\n\n/**\n* Helper type used by `PopulatedDocument`. Removes the `ObjectId` from the general union type generated \n* for ref documents (i.e. `mongoose.Types.ObjectId | UserDocument` -> `UserDocument`)\n*/\ntype PopulatedProperty<Root, T extends keyof Root> = Omit<Root, T> & { \n  [ref in T]: Root[T] extends mongoose.Types.Array<infer U> ? \n    mongoose.Types.Array<Exclude<U, mongoose.Types.ObjectId>> :\n    Exclude<Root[T], mongoose.Types.ObjectId> \n}\n\n/**\n * Populate properties on a document type:\n * ```\n * import { PopulatedDocument } from \"../interfaces/mongoose.gen.ts\"\n *\n * function example(user: PopulatedDocument<UserDocument, \"bestFriend\">) {\n *   console.log(user.bestFriend._id) // typescript knows this is populated\n * }\n * ```\n */\nexport type PopulatedDocument<\nDocType,\nT\n> = T extends keyof DocType\n? PopulatedProperty<DocType, T> \n: (\n    ParentProperty<T> extends keyof DocType\n      ? Omit<DocType, ParentProperty<T>> &\n      {\n        [ref in ParentProperty<T>]: (\n          DocType[ParentProperty<T>] extends mongoose.Types.Array<infer U> ? (\n            mongoose.Types.Array<\n              ChildProperty<T> extends keyof U \n                ? PopulatedProperty<U, ChildProperty<T>> \n                : PopulatedDocument<U, ChildProperty<T>>\n            >\n          ) : (\n            ChildProperty<T> extends keyof DocType[ParentProperty<T>]\n            ? PopulatedProperty<DocType[ParentProperty<T>], ChildProperty<T>>\n            : PopulatedDocument<DocType[ParentProperty<T>], ChildProperty<T>>\n          )\n        )\n      }\n      : DocType\n  )\n\n";
export declare const QUERY_POPULATE = "/**\n * Helper types used by the populate overloads\n */\ntype Unarray<T> = T extends Array<infer U> ? U : T;\ntype Modify<T, R> = Omit<T, keyof R> & R;\n\n/**\n * Augment mongoose with Query.populate overloads\n */\ndeclare module \"mongoose\" {\n  interface Query<ResultType, DocType, THelpers = {}> {\n    populate<T extends string>(path: T, select?: string | any, model?: string | Model<any, THelpers>, match?: any): Query<\n      ResultType extends Array<DocType> ? Array<PopulatedDocument<Unarray<ResultType>, T>> : (ResultType extends DocType ? PopulatedDocument<Unarray<ResultType>, T> : ResultType),\n      DocType,\n      THelpers\n    > & THelpers;\n\n    populate<T extends string>(options: Modify<PopulateOptions, { path: T }> | Array<PopulateOptions>): Query<\n      ResultType extends Array<DocType> ? Array<PopulatedDocument<Unarray<ResultType>, T>> : (ResultType extends DocType ? PopulatedDocument<Unarray<ResultType>, T> : ResultType),\n      DocType,\n      THelpers\n    > & THelpers;\n  }\n}";
export declare const getObjectDocs: (modelName: string) => string;
export declare const getQueryDocs: () => string;
export declare const getQueryHelpersDocs: (modelName: string) => string;
export declare const getModelDocs: (modelName: string) => string;
export declare const getDocumentDocs: (modelName: string) => string;
export declare const getSchemaDocs: (modelName: string) => string;
export declare const getLeanDocs: (modelName: string, fullName?: string | undefined) => string;
export declare const getSubdocumentDocs: (modelName: string, path: string) => string;
